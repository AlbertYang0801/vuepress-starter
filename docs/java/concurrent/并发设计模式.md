# 

## 单例模式

单例模式和并发并没有太大关系，但是线程安全的单例模式在并发情况下应用很广泛。可以使用推荐的单例模式实现方式，来实现并发情况下的共享对象。

[技术小站-单例模式](https://albertyang0801.github.io/blog/design/build/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html)

## 不变模式

不变模式的核心就是：**一个对象创建后，内部状态将永远不会发生改变**。这样即使在多线程情况下，每个线程获取到的对象都是一致的，所以针对不变模式的对象，不需要考虑线程安全问题。

### 使用场景

1. 对象创建后，对象内部状态和数据都不会再改变。
2. 对象需要共享，支持并发访问。

### 实现方式

1. 对象去除 setter 方法。
2. 不提供修改自身属性的方法。
3. 将所有属性设置为 private，并添加 final 关键字，确保属性不会被修改。
4. 提供一个可以创建完整对象的构造函数。
5. 确保不存在子类可以重载修改它的行为（最好不存在子类）。

---

```java
//final修饰的类不能被继承
public final class Product {

  	//属性私有且final修饰
    private final String no;
    private final String name;
    private final double price;
		
  	//创建完整对象的构造方法
    public Product(String no, String name, double price){
        super();
        this.no=no;
        this.name=name;
        this.price=price;
    }

    public String getNo() {
        return no;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }
}
```



## 生产者-消费者模式

生产者-消费者模式通过对生产者线程和消费者线程进行解耦合，通过**共享缓冲区**进行通信，满足并发情况下的访问问题。

共享缓冲区的主要功能就是**实现多线程情况下的数据共享**，还可以缓解生产者和消费者之间的性能差距。

![临时文件 (16)](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210929172852.png)

Java 中能充当内存缓冲区的数据结构有很多，支持并发的容器，比如 `BlockingQueue`就可以作为共享缓冲区来使用。



## 本地存储模式-ThreadLocal

在并发情况下，对象的共享问题可以通过本地存储模式解决，即每个线程都有一个属于线程本身的对象副本。而 Java 提供了对应的类 - `ThreadLocal`。

[技术小站-ThreadLocal总结](https://albertyang0801.github.io/blog/java/concurrent/tool/ThreadLocal.html)



## Future模式

CompletableFuture增强

