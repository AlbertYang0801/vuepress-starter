# 并发设计模式

## 单例模式

单例模式和并发并没有太大关系，但是线程安全的单例模式在并发情况下应用很广泛。可以使用推荐的单例模式实现方式，来实现并发情况下的共享对象。

[技术小站-单例模式](https://albertyang0801.github.io/blog/design/build/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html)

## 不变模式

不变模式的核心就是：**一个对象创建后，内部状态将永远不会发生改变**。这样即使在多线程情况下，每个线程获取到的对象都是一致的，所以针对不变模式的对象，不需要考虑线程安全问题。

### 使用场景

1. 对象创建后，对象内部状态和数据都不会再改变。
2. 对象需要共享，支持并发访问。

### 实现方式

1. 对象去除 setter 方法。
2. 不提供修改自身属性的方法。
3. 将所有属性设置为 private，并添加 final 关键字，确保属性不会被修改。
4. 提供一个可以创建完整对象的构造函数。
5. 确保不存在子类可以重载修改它的行为（最好不存在子类）。

---

```java
//final修饰的类不能被继承
public final class Product {

  	//属性私有且final修饰
    private final String no;
    private final String name;
    private final double price;
		
  	//创建完整对象的构造方法
    public Product(String no, String name, double price){
        super();
        this.no=no;
        this.name=name;
        this.price=price;
    }

    public String getNo() {
        return no;
    }

    public String getName() {
        return name;
    }

    public double getPrice() {
        return price;
    }
}
```



## 生产者-消费者模式

生产者-消费者模式通过对生产者线程和消费者线程进行解耦合，通过**共享缓冲区**进行通信，满足并发情况下的访问问题。

共享缓冲区的主要功能就是**实现多线程情况下的数据共享**，还可以缓解生产者和消费者之间的性能差距。

![临时文件 (16)](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210929172852.png)

Java 中能充当内存缓冲区的数据结构有很多，支持并发的容器，比如 `BlockingQueue`就可以作为共享缓冲区来使用。



## 本地存储模式-ThreadLocal

在并发情况下，对象的共享问题可以通过本地存储模式解决，即每个线程都有一个属于线程本身的对象副本。而 Java 提供了对应的类 - `ThreadLocal`。

[技术小站-ThreadLocal总结](https://albertyang0801.github.io/blog/java/concurrent/tool/ThreadLocal.html)



## Future模式

在多线程中，当线程 A 需要线程 B 的计算结果时，假设计算耗时较长，线程 A 往往需要等待。若线程 A 不希望等待线程 B ，则可以先拿到一个线程 B 的 Future，等 B 计算完成之后从 Future 中即可获取到计算结果。

Future 的核心思想是 **异步调用**。



### JDK中的Future模式

JDK 中提供了 Future 模式，与线程创建类 `Callable` 搭配使用。

`Callable` 接口只有一个方法 `call()` ,它能够返回结果，并且开启一个线程。

![临时文件 (18)](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210930102855.png)

- `Future`

  JDK 中的 Future 接口提供了一些方法，其中 `get()` 方法就是获取异步计算的结果方法，若不指定超时时间，则存在阻塞的问题。

  ```java
  public interface Future<V> {
  
    	//取消任务
      boolean cancel(boolean mayInterruptIfRunning);
  		//是否已经取消
      boolean isCancelled();
  		//是否已经完成
      boolean isDone();
    	//获取数据，会阻塞
      V get() throws InterruptedException, ExecutionException;
    	//获取数据，指定超时时间
      V get(long timeout, TimeUnit unit)
          throws InterruptedException, ExecutionException, TimeoutException;
  }
  ```

- `RunnableFuture`

  `RunnableFuture` 继承了 `Runnable` 和 `Future `, 但是它还是个接口。它提供了两个功能，一是可以被当作线程执行，二是可以作为 Future 获取 Callable 的返回值。

  ```java
  public interface RunnableFuture<V> extends Runnable, Future<V> {
      
      void run();
  }
  ```

  

- `FutureTask`

  `FutureTask` 实现了 `RunnableFuture` ，这也意味着 `FutureTask` 才是真正用来使用的对象。`FutureTask` 具备了 `RunnableFuture` 的功能，即可以当作线程执行，也可以作为 Future 获取 Callable 的返回值，同时 FutureTask 还实现了 Future 接口的方法。

  FutureTask 的 get() 方法是获取计算结果，若结果未完成计算，就会发生阻塞（通过阻塞工具 LockSupport 实现）。

  ```java
  public class FutureTask<V> implements RunnableFuture<V> {
    	//构造方法Callable
      public FutureTask(Callable<V> callable) {
          if (callable == null)
              throw new NullPointerException();
          this.callable = callable;
          this.state = NEW;       // ensure visibility of callable
      }
    	//构造方法Runnable
      public FutureTask(Runnable runnable, V result) {
          this.callable = Executors.callable(runnable, result);
          this.state = NEW;       // ensure visibility of callable
      }
    
    	//get()方法阻塞
      public V get() throws InterruptedException, ExecutionException {
          int s = state;
          if (s <= COMPLETING)
            	//阻塞等待
              s = awaitDone(false, 0L);
          return report(s);
      }
    
    	//阻塞的方法
    	private int awaitDone(boolean timed, long nanos)
          throws InterruptedException {
          final long deadline = timed ? System.nanoTime() + nanos : 0L;
          WaitNode q = null;
          boolean queued = false;
        	//自旋
          for (;;) {
              if (Thread.interrupted()) {
                  removeWaiter(q);
                  throw new InterruptedException();
              }
  
              int s = state;
              if (s > COMPLETING) {
                  if (q != null)
                      q.thread = null;
                  return s;
              }
              else if (s == COMPLETING) // cannot time out yet
                	//让出线程资源
                  Thread.yield();
              else if (q == null)
                  q = new WaitNode();
              else if (!queued)
                	//CAS
                  queued = UNSAFE.compareAndSwapObject(this, waitersOffset,
                                                       q.next = waiters, q);
              else if (timed) {
                  nanos = deadline - System.nanoTime();
                  if (nanos <= 0L) {
                      removeWaiter(q);
                      return state;
                  }
                	//阻塞工具LockSupport，实现限时阻塞
                  LockSupport.parkNanos(this, nanos);
              }
              else
                	//直接阻塞
                  LockSupport.park(this);
          }
      }
    
    
  }
  ```

---

**代码练习**

```java
@SneakyThrows
    public static void main(String[] args) {
        RealData realData = new RealData("hello");
        FutureTask<String> futureTask = new FutureTask<>(realData);
        //搭配线程池
        ExecutorService executorService = Executors.newCachedThreadPool();
        executorService.submit(futureTask);
        System.out.println("提交任务结束");

        try {
            System.out.println("异步开始进行");
            Thread.sleep(5000);
            System.out.println("异步结束进行");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //get()方法是阻塞的，在这里阻塞相当于还是同步
        String content= futureTask.get();
        System.out.println("异步获取计算结果："+content);
        executorService.shutdown();
    }
```



**Future模式的不足**

Future 模式本质上是异步调用，但是获取计算结果的线程和任务执行不是同一个线程，计算结果需要通过 `get()` 方法获取。若在结果未计算完成时调用 `get()` 方法，则会发生阻塞，又变为了同步状态。所以 Future 模式在效率上的提高是有限的。

除了阻塞还可以通过**轮询**的方式来判断数据是否计算完成，同样存在效率问题。



### CompletableFuture

Future 在获取结果的时候只能采用轮询或者阻塞等待的方式，不是真正意义上的异步，而 JDK1.8 更新的 `CompletableFuture` 可以实现真正意义上的异步。

- 完成通知 - `complete`

  完成通知。

  ```java
  public class AskThread implements Runnable {
      private CompletableFuture<Integer> completableFuture = null;
  
      public AskThread(CompletableFuture<Integer> completableFuture) {
          this.completableFuture = completableFuture;
      }
  
      @Override
      public void run() {
          try {
              int content = completableFuture.get() * completableFuture.get();
              System.out.println(content);
          } catch (InterruptedException | ExecutionException e) {
              e.printStackTrace();
          }
      }
  
      @SneakyThrows
      public static void main(String[] args) {
          CompletableFuture<Integer> future = new CompletableFuture<>();
          new Thread(new AskThread(future)){}.start();
          //模拟结果的计算过程
          Thread.sleep(3000);
          //完成之后进行通知
          future.complete(50);
      }
  
  }
  ```

- 异步调用 - `supplyAsync`

  使用该方法能够实现异步调用，该方法内部封装了线程池，类似 Future 的异步调用。

  ```java
      @SneakyThrows
      public static Integer calc(int num) {
          Thread.sleep(3000);
          return num * num;
  //        return num / 0;
      }
  
  		@SneakyThrows
      public static void main(String[] args) {
          //supplyAsync 异步计算
          CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> calc(100));
          //get()方法会阻塞
          System.out.println(completableFuture.get());
      }
  ```

  注意：`get()` 方法同样会阻塞。

- 流式调用 - `thenAccept`

  `CompletableFuture` 增加了流式调用的功能，`thenAccept` 传入的函数式接口式 `Function<T, R>`，有返回值。在异步方法调用完成后按照顺序调用该方法。

  ```java
      @SneakyThrows
      @Test
      public void testThenApply() {
          //流式调用
          CompletableFuture<String> voidCompletableFuture = CompletableFuture.supplyAsync(() -> calc(100))
                  //任务完成后的回调方法
                  .thenApply((value) -> {
                      System.out.println("异步任务计算完成！！！");
                      return String.valueOf(value + 1);
                  });
          //阻塞等待
          System.out.println("阻塞主线程:"+voidCompletableFuture.get());
      }
  
  
  //output
  异步任务计算完成！！！
  阻塞主线程:10001
  ```

- `thenAccept`

  `thenAccept` 传入的函数式接口式 `Consumer<T>`，无返回值。在异步方法调用完成后按照顺序调用该方法。

  ```java
      @SneakyThrows
      @Test
      public void testThenAccept() {
          //流式调用
          CompletableFuture<Void> voidCompletableFuture = CompletableFuture.supplyAsync(() -> calc(100))
                  //任务完成后的回调方法
                  .thenApply((value) -> {
                      System.out.println("异步任务计算完成！！！");
                      return String.valueOf(value + 1);
                  }).thenAccept(System.out::println);
          //阻塞等待
          System.out.println("阻塞主线程:"+voidCompletableFuture.get());
      }
  ```

- 异常处理 - `exceptionally`

  可以通过该方法增加流式处理过程中的异常处理。

  ```java
      @Test
      public void testExce() throws InterruptedException {
          //流式调用增加异常处理
          CompletableFuture.supplyAsync(() -> calc(30))
                  .exceptionally(ex -> {
                      System.out.println(ex.getMessage());
                      return 0;
                  }).thenAccept(System.out::println);
          Thread.sleep(5000);
      }
  ```

  

### Guava提供的Future

Guava 对 Future 进行了增加，增加了通知回调的功能，实现了异步的效果。

```java
    @SneakyThrows
    @Test
    public void guavaFuture() {

        //1.使用Guava的增强线程池
        ListeningExecutorService listeningExecutorService =
                MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
        RealData task = new RealData("hello");
        //2.提交任务
        ListenableFuture<String> future = listeningExecutorService.submit(task);

        //3.为异步任务增加监听，任务完成自动调用回调方法
        future.addListener(() -> {
            try {
              	//回调方法逻辑
                System.out.println("异步任务执行结束");
                String content = future.get();
                System.out.println("调用回调方法结果为：" + content);
                //关闭线程池
                listeningExecutorService.shutdown();
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }
        }, listeningExecutorService);

        //非阻塞进行其他任务
        Thread.sleep(20000);
        System.out.println("进行其他业务处理");
    }
```

还可以为 Future 增加成功和异常时的回调方法。

```java
   /**
     * 增加对异常的处理
     */
    @SneakyThrows
    @Test
    public void guavaFutureErr() {

        //使用Guava的增强线程池
        ListeningExecutorService listeningExecutorService =
                MoreExecutors.listeningDecorator(Executors.newFixedThreadPool(10));
        RealData task = new RealData("hello");
        //提交任务
        ListenableFuture<String> future = listeningExecutorService.submit(task);

        //增加任务的监听，同时增加成功和失败时的回调方法
        Futures.addCallback(future, new FutureCallback<String>() {
            @Override
            public void onSuccess(@Nullable String s) {
                try {
                    System.out.println("异步任务执行结束");
                    String content = future.get();
                    System.out.println("调用回调方法结果为：" + content);
                    //关闭线程池
                    listeningExecutorService.shutdown();
                } catch (InterruptedException | ExecutionException e) {
                    e.printStackTrace();
                }
            }

            @Override
            public void onFailure(Throwable throwable) {
                System.out.println("回调失败！！！！！！");
            }
        });

        //非阻塞进行其他任务
        Thread.sleep(5000);
        System.out.println("进行其他业务处理");
    }

```















