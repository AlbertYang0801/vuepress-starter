# 缓存淘汰算法

## FIFO-先进先出

![](https://s2.loli.net/2025/05/29/sBnDWI6qKlCapc1.png)

比较简单，不够灵活。

没有跟缓存使用频次和时间等维度联系起来。

## LRU-最近最少使用

核心思想是**最近使用的时间**。比如最近一小时以内使用缓存的时间。

![](https://s2.loli.net/2025/05/29/pIrVCw8Q2GzuUoO.png)

根据数据的历史访问记录来淘汰数据，淘汰最久未被使用的数据。

基于**如果数据最近被访问过，那么将来访问的记录会更高**。优先淘汰最久未被使用的冷数据。

## LFU-最近最不常用

核心思想是最近使用的次数。比如最近一小时内使用缓存的次数。

![](https://s2.loli.net/2025/05/29/tNSXLjZzckpP4f9.png)

LFU能够提高热点数据的命中率。

但是当缓存中数据都是热点数据的时候，将失去该特性。

**单纯的LFU存在缺陷**。

比如目前缓存中都是热点数据，新加进来的缓存没有被访问过，就会被基于访问次数的LFU淘汰。导致新缓存无效。

> 可以为新缓存设置一个中位数的访问次数，防止缓存直接被淘汰。
> 

## SLRU- 分段最近最少使用

LRU算法存在个问题，就是如果元素只被访问一次的情况下，很可能被其它元素挤出去。

比如遇到列表遍历这种写入缓存，很可能把大量缓存挤出去，留下一堆很可能不会再访问的元素在缓存中，导致缓存命中率下降。

### SLRU设计

SLRU将缓存分为两段，一段是淘汰段，一段是保护段。两段都基于LRU算法进行淘汰。

访问过一次的元素在访问第二次的时候会放入保护段。

淘汰元素时候只会在淘汰段淘汰。保护段淘汰的元素进入淘汰段。这样能有效保护数据不会被只访问一次的数据给淘汰。

![](https://s2.loli.net/2025/05/29/oFaKrbBGLn8xTvN.png)