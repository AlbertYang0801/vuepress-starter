Java 内存模型在 JDK1.7 主要包含以下区域。

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 方法区
- 堆

而在 JDK1.8中将运行时数据区中的方法区给取消了，换成了直接内存中的元数据区。

- 程序计数器
- 虚拟机栈
- 本地方法栈
- 堆
- 元数据区

## 内存模型图


1. JDK 1.7 内存模型图

![](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210611155359.png)

2. JDK 1.8 内存模型图

   JDK1.8中取消了运行时数据区中的方法区，换成了元数据区放到了直接内存里。

![](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210611160927.png)



## 运行时数据区
### 1、程序计数器

程序计数器是是线程私有的，各个线程之间互不影响。保存的是程序执行到的指令地址。

- 如果线程执行的是非 native 方法，则程序计数器保存的是当前需要执行的指令地址。
- 如果线程执行的是 native 方法，则程序计数器中的值是 undefined。

由于程序计数器保存的数据占用空间不会随程序执行而改变，因为程序计数器是内存区域中没有规定 OutOfMemoryError 情况的区域。

### 2、虚拟机栈

虚拟机栈是常说的栈内存，是 Java 方法执行的区域，虚拟机栈存放的是一个个栈帧，每个栈帧对应一个调用的方法。虚拟机栈是线程私有的，每个线程都有自己的虚拟机栈，保存了线程私有的 Java 方法。

栈帧包含局部变量表、操作数栈、指向运行时常量池的引用、方法返回地址、附加信息。

![](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/Snipaste_2021-06-16_22-44-43.png)

- 局部变量表

  > 主要用来保存方法中的局部变量，包含方法中声明的非静态变量和函数形参。

  - 基本数据类型保存值。
  - 引用类型，保存的是对象引用地址。

  局部变量表的大小在编译器可以指定其大小，因此在程序执行期间局部变量表的大小是不会改变的。

- 操作数栈

  > 是方法中进行数据运算的地方。用来计算表达式求值，程序中的计算过程都是借助于操作数栈来完成的。

- 指向引用时常量池的引用

  > 因为在方法执行的过程中可能需要用到类中的变量，所以每个方法也就是栈帧需要保存一个执行运行时常量的引用。

  运行时常量池在方法区中。

- 方法返回地址

  > 在线程中，每个方法执行完成之后，需要返回到之前调用它的地方。所以在栈帧中需要保存方法的返回地址。由于每个线程执行的方法可能不同，所以每个线程都要有一个自己的虚拟机栈。故而虚拟机栈是线程私有的。

  当线程执行一个方法的时候，对应创建一个栈帧压栈。当方法执行完毕之后，便会将栈帧出栈。

  线程当前执行的方法必定位于虚拟机栈的顶部。在该区域会发生两种异常。

  - 如果线程请求的栈大于虚拟机允许的深度，会抛出 StackOverFlowError异常。
  - 如果虚拟机栈可以动态扩展，当扩展到无法申请到足够内存时，就会抛出 OutOfMemoryError异常。

### 3、本地方法栈

本地方法栈和虚拟机栈的作用很相似，虚拟机栈为虚拟机执行 Java 方法，而本地方法栈则为 Java 方法使用到的本地方法服务（navite 方法）。相同的本地方法栈也可能抛出 StackOverFlowError 和 OutOfMemoryError 异常。

![](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/Snipaste_2021-06-16_23-34-22.png)

### 4、堆
### 5、方法区
### 6、运行时常量池
### 7、直接内存


## 参考链接

[Java内存管理-JVM内存模型以及JDK7和JDK8内存模型对比总结（三）](https://juejin.cn/post/6844903909983535111#heading-8)



