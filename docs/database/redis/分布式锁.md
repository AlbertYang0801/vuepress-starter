# 分布式锁

## 分布式锁实现方式

1. MySQL 实现
2. zeekeeper 实现分布式锁
3. redis 实现分布式锁

## redis 实现分布式锁

### setnx 命令

使用 `setnx` 命令可以实现分布式锁。`setnx` 命令在设置 key 值时，若 key 已存在，则直接返回，只有  key 不存在时，才会添加成功。

- 加锁

  ```shell
  setnx good_key
  ```

- 解锁

  ```shell
  del good_key
  ```



1. 简单使用 `setnx` 实现分布式锁。

   ```java
          /**
        * 3.0 版本
        * 加分布式锁 - 解决超卖问题
        */
       public String oversoldGoodVersionThree() {
           //不断请求锁
           while (true) {
               //加分布式锁 setNx
               Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(GOOD_LOCK, UUID.randomUUID().toString());
               if (Objects.isNull(lock)) {
                   continue;
               }
               //获取到锁
               if (lock) {
                   //获取商品数量
                   String stock = stringRedisTemplate.opsForValue().get(GOOD_KEY);
                   int goods = StringUtils.isEmpty(stock) ? 0 : Integer.parseInt(stock);
   
                   if (goods <= 0) {
                       System.out.println("商品已经卖完了");
                       return "商品已经卖完";
                   }
   
                   //减库存
                   int realGoodCount = goods - 1;
                   stringRedisTemplate.opsForValue().set(GOOD_KEY, String.valueOf(realGoodCount));
                   System.out.println("成功买到商品");
                   //解锁
                   stringRedisTemplate.delete(GOOD_LOCK);
                   return "成功买到商品";
               }
           }
       }
   ```

   上述代码存在问题，不能保证分布式锁最终顺利解锁。

2. 保证分布式锁顺利解锁，增加 finally 代码块。

   ```java
       public String oversoldGoodVersionFour() {
           try {
               //不断请求锁
               while (true) {
                   //加分布式锁 setNx
                   Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(GOOD_LOCK, UUID.randomUUID().toString());
                   if (Objects.isNull(lock)) {
                       continue;
                   }
                   //获取到锁
                   if (lock) {
                       //获取商品数量
                       String stock = stringRedisTemplate.opsForValue().get(GOOD_KEY);
                       int goods = StringUtils.isEmpty(stock) ? 0 : Integer.parseInt(stock);
   
                       if (goods <= 0) {
                           System.out.println("商品已经卖完了");
                           return "商品已经卖完";
                       }
                       //减库存
                       int realGoodCount = goods - 1;
                       stringRedisTemplate.opsForValue().set(GOOD_KEY, String.valueOf(realGoodCount));
                       System.out.println("成功买到商品");
                       return "成功买到商品";
                   }
               }
           } finally {
               //解锁
               stringRedisTemplate.delete(GOOD_LOCK);
           }
   
       }
   ```

   上述代码虽然能保证最终解锁，但是若因为物理原因导致程序重启，最终没有走到 finally 块。但是在 redis 中对应的锁一直都存在，导致后续无法获取锁。

3. 对分布式锁增加过期时间，来保证解锁。

   注意，要保证设置锁和设置锁过期时间的原子性，使用一个 redis 命令。

   ```java
       public String oversoldGoodVersionFive() {
           try {
               //不断请求锁
               while (true) {
                   //加分布式锁 setNx（增加过期时间）
                   Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(GOOD_LOCK, UUID.randomUUID().toString(),
                           1000L, TimeUnit.SECONDS);
                   if (Objects.isNull(lock)) {
                       continue;
                   }
                   //获取到锁
                   if (lock) {
                       //获取商品数量
                       String stock = stringRedisTemplate.opsForValue().get(GOOD_KEY);
                       int goods = StringUtils.isEmpty(stock) ? 0 : Integer.parseInt(stock);
   
                       if (goods <= 0) {
                           System.out.println("商品已经卖完了");
                           return "商品已经卖完";
                       }
                       //减库存
                       int realGoodCount = goods - 1;
                       stringRedisTemplate.opsForValue().set(GOOD_KEY, String.valueOf(realGoodCount));
                       System.out.println("成功买到商品");
                       return "成功买到商品";
                   }
               }
           } finally {
               //解锁
               stringRedisTemplate.delete(GOOD_LOCK);
           }
       }
   ```

   上述增加了锁过期的机制，是为了解决锁可能无法正常被解决的问题。但是也引来了新的问题。比如业务逻辑未执行完成，锁过期。

   锁过期会导致其他线程在自旋的过程可以拿到分布式锁，进行业务处理。最终会导致在线程结束删除锁时，删除的不是自己的锁。

   ![商品预约](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210721213930.png)

4. 对分布式锁增加线程标识，保证删除的是自己线程新建的锁。

   ```java
   public String oversoldGoodVersionSix() {
     	//当前线程作为
       String value = UUID.randomUUID().toString() + Thread.currentThread().toString();
       try {
           //不断请求锁
           while (true) {
               //加分布式锁 setNx（增加过期时间）
               Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(GOOD_LOCK, value,
                       1000L, TimeUnit.SECONDS);
               if (Objects.isNull(lock)) {
                   continue;
               }
               //获取到锁
               if (lock) {
                   //获取商品数量
                   String stock = stringRedisTemplate.opsForValue().get(GOOD_KEY);
                   int goods = StringUtils.isEmpty(stock) ? 0 : Integer.parseInt(stock);
   
                   if (goods <= 0) {
                       System.out.println("商品已经卖完了");
                       return "商品已经卖完";
                   }
                   //减库存
                   int realGoodCount = goods - 1;
                   stringRedisTemplate.opsForValue().set(GOOD_KEY, String.valueOf(realGoodCount));
                   System.out.println("成功买到商品");
                   return "成功买到商品";
               }
           }
       } finally {
           //删除自己的锁
           if(Objects.requireNonNull(stringRedisTemplate.opsForValue().get(GOOD_KEY)).equalsIgnoreCase(value)){
               //解锁
               stringRedisTemplate.delete(GOOD_LOCK);
           }
       }
   }
   ```

