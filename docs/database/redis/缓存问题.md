# 缓存问题

## 前言

在使用缓存的时候，简单的缓存处理流程如下。针对如下流程会遇到缓存穿透、缓存击穿、缓存雪崩等问题。

![临时文件 (1)](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210807191220.png)

## 缓存穿透

缓存穿透：**当用户请求查询某个数据时，先从缓存查询，缓存中没有这个数据。然后向数据库查询数据，数据库中也没有这个数据，导致查询失败。**

*像一些恶意攻击时，故意查询数据库中不存在的数据，比如查询 id = -1 的数据，会造成数据库压力非常大。*

![临时文件 (3)](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210807192757.png)

#### 解决方案

1. **对空值做缓存。**

   **当出现从缓存和数据库都查不到数据的情况时，可以将空值存到缓存中，即 K-V 存为 key-null，缓存过期时间可以设置短点，来防止短时间的频繁恶意攻击。**

   由于将空值存放到了缓存中，存在的问题：

   - 缓存需要内存空间存放空值。
   - 对空值设置了过期时间，导致缓存和数据库中的数据可能出现不一致的问题（数据库中有真实数据，而缓存中的空值数据未过期），不能保证数据一致性。

2. **设置可访问 IP 的白名单，防止恶意攻击。**

   针对可能出现的恶意攻击情况，使用 **bitmaps** 存放白名单（可以访问的 IP 地址）。

   存在的问题：

   - 在每次查询之前，都需要判断是否在白名单中，影响效率。

3. **使用布隆过滤器。**

   布隆过滤器是一种数据结构，**能够很快的判断某个数据是否存在**。

   *在查询数据之前，先从布隆过滤器判断数据是否存在，若存在，则继续从缓存开始查数据。若是不存在，则不继续查询。*

   存在的问题：

   - 布隆过滤器存在误判的情况。
   
     若布隆过滤器判断数据不存在，则一定不存在。
   
     若布隆过滤器判断数据存在，则不一定存在。



## 缓存击穿

缓存击穿：**当缓存中某个热点数据过期后，用户从缓存中查不到数据，然后去查询数据库，由于热点数据访问频率高，导致大量请求查询数据库，造成数据库压力过大，即发生了缓存击穿。**

*注意发生缓存击穿的时候，redis 是正常的，redis 中不会发生大量 key 过期的问题，只是数据库受到了很大的访问压力。*



![临时文件 (4)](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210807200938.png)

#### 解决方案

1. 设置热点数据永不过期。

2. 预先延长热点数据的过期时间。

   在能够提前知道高并发情况时，预先延长热点数据的过期时间来避免缓存击穿。

3. 使用锁。

   在高并发访问热点数据的情况下，若缓存中没有数据，对**访问数据库数据并添加到缓存中的过程**加锁。

   ```java
   public String query(String key){
     //1.从缓存查询数据
   	String result = getResultForCache(key);
   	//2.缓存中没数据
     if(result==null){
       //获取锁
       if(lock.tryLock()){
         //从数据库查数据
         result=getDataForMySQL(key);
         //添加到缓存中
        	setDataToCache(result);
       }else{
         Thread.sleep(100);
         //没获取到锁的，睡眠100ms，再重新查询缓存
         result=query(key);
       }
     }
   
     
   }
   ```

   

## 缓存雪崩

缓存雪崩：**在短时间内，缓存中的大量 key 集中过期，导致大量请求去查询数据库，导致数据库压力过大。**

#### 解决方案

1. 锁或者队列。

   在高并发情况访问缓存时，增加锁或者队列，来确保同一时间不会有多个线程同时访问缓存。

   *加锁或队列是一种治标不治本的方式，虽然能够解决缓存雪崩的问题，但是没有提高系统吞吐量，在高并发情况下，阻塞问题严重。而且若是在分布式环境下，需要使用分布式锁，导致系统效率大大降低。*

2. 将缓存失效时间分散。

   在设置缓存失效时间时，增加随即因子，保证失效时间的随机性，减少大量 key 集中过期的问题。

3. 设置缓存永不过期。

   设置缓存永不过期需要更多的内存空间。



