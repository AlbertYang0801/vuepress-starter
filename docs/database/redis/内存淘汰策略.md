# 内存淘汰策略

## 最大内存设置

1. redis 默认内存是多少？

   在 64 位操作系统不限制内存大小，在 32 位操作系统下最多使用 3GB。

2. 查看 redis 最大内存？

   ```
   config get maxmemory
   ```

   ![image-20210725225656431](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210725230010.png)

3. 修改 redis 内存大小？

   - 修改配置文件

     在 `redis.conf` 第 859 行可以设置最大内存大小（单位是字节）。

     > : set nu 可以显示文件行号

     ![image-20210725222546949](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210725222546.png)

   - 使用命令配置

     ```shell
     config set maxmemory 100
     ```

     ![image-20210725225927031](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210725225927.png)

4. redis 内存满了之后会怎样?

   采用内存淘汰策略，默认是 `no-enviction`，会抛出 OOM 异常。

   ![image-20210725230125654](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210725230125.png)

5. 查看内存信息

   ```
   info memory
   ```

   ![image-20210725230742686](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210725230742.png)

6. 生产上一般怎么设置内存？

   推荐设置内存为**最大物理内存的四分之三**。

---


## redis内存淘汰策略

### 八种内存淘汰策略

在 redis.conf 文件中有体现。

![image-20210725232238442](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210725232238.png)

- 2个范围
    - 所有 key。
    - 设置了过期时间的 key。
- 4个方式
    - LRU 算法。
    - LFU 算法。
    - random - 随机删除。
    - ttl - 删除马上要过期的。


---

1. volatile-lru：对所有设置了过期时间的 key 使用 LRU 算法进行删除。
2. allkeys-lru：对所有 key 使用 LRU 算法进行删除。
3. volatile-lfu：对所有设置了过期时间的 key 使用 LFU 算法进行删除。
4. allkeys-lfu：对所有 key 使用 LFU 算法进行删除。
5. volatile-random ：对所有设置了过期时间的 key 随机删除。
6. allkeys-random ：对所有 key 随机删除。
7. volatile-ttl：删除马上要过期的 key。
8. noeviction：**默认的内存淘汰策略**，禁止删除数据，能保证数据不丢失。当内存满了的时候，再写入数据会返回错误。



> LRU 算法：最近最久未使用。
>
> LFU 算法：最近使用次数最少。



### 设置内存淘汰策略

1. 配置文件设置

![image-20210726004413838](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210726004413.png)

​	在 redis.conf 配置文件中 `maxmemory-policy` 对应设置内存淘汰策略，注释提示了默认淘汰策略是 `noeviction`。通过修改该配置就可以修改内存淘汰策略。

2. 命令行设置

   ```java
   // 获取maxmemory-policy配置
   127.0.0.1:6379> config get maxmemory-policy
   // 设置maxmemory-policy配置为allkeys-lru
   127.0.0.1:6379> config set maxmemory-policy allkeys-lru
   ```

### 如何选择内存淘汰策略

- 若所有数据访问频率一样，可以使用 `allkeys-random`。
- 若有一部分是热点数据，有一部分是冷门数据，可以考虑使用 `allkeys-lru`。
- 若希望有一部分数据被长期保存，而有些可以被删除。可以选择 `volatile-lru`或 `volatile-random`。
- 若希望避免设置 key 的失效时间来减少内存的使用。可以使用 `allkeys-lru` 搭配 key 不设置过期时间来高效利用内存。



## LRU算法

### LRU 算法简介

LRU （Least Recently Used） 算法即**最近最久未使用**，每次选择最近最久未使用的页面淘汰掉。

### 数据结构

LRU 算法内部的数据结构需要根据元素的访问时间排序。还需要查找、插入、删除等效率要高。

1. 查找、插入、删除快。
2. 支持排序。

在常用的集合中，有的是查找更新快或者插入删除快，没有数据结构能同时满足以上条件，所以需要采用组合的数据结构。

在 LRU 算法中，使用的是**哈希链表**的数据结构，来同时保证查找、插入、删除的速度，同时链表还能够满足排序。

![未命名文件 (1)](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6%20(1).png)

### LinkedHashMap

LinkedHashMap 底层数据结构是哈希链表，是 `HashMap + DoubleLinkedList`，其中 HashMap 用来存放数据，而 DoubleLinkedList 用来维护插入元素的先后顺序。

在 LinkedHashMap 中有一个方法 `removeEldestEntry` 是支持 LRU 算法的。

```JAVA
    protected boolean removeEldestEntry(Map.Entry<K,V> eldest) {
        //默认为false
        return false;
    }
```

当方法 `removeEldestEntry` 返回 true 的时候，会删除集合内最旧的元素。在每次新增元素调用 `put` 或 `putAll` 方法时，新增完元素之后调用该方法，以此来减少内存消耗。

```java
public class LruCacheDemo<K,V> extends LinkedHashMap<K,V> {

    //容量
    private int capacity;

    public LruCacheDemo(int capacity){
        //accessOrder:访问顺序（true，内部元素会按照访问顺序重新排列；false：内部元素不会按照访问顺序重新排列）
        //符合 LRU 算法时，新访问的数据要重新排列到队尾，以免提前出队。
        super(capacity,0.75F,false);
        this.capacity=capacity;
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<K, V> eldest) {
     	//重写该方法，当集合容量>预设容量时，删除最近最久未使用的元素，这也是实现 LRU 算法的关键。
        return super.size()>capacity;
    }
}
```

其中，LinkedHashMap 的构造函数中有一个参数为 accessOrder，代表集合内部元素是否根据访问顺序重新排列。

以下面测试例子为例来区分 accessOrder 参数的作用。

```java
    public static void main(String[] args) {
        LruCacheDemo<Integer,Integer> lruCacheDemo = new LruCacheDemo<Integer,Integer>(3);

        lruCacheDemo.put(1,1);
        lruCacheDemo.put(2,2);
        lruCacheDemo.put(3,3);
        System.out.println(lruCacheDemo.keySet());

        lruCacheDemo.put(4,4);
        System.out.println(lruCacheDemo.keySet());

        lruCacheDemo.put(3,3);
        lruCacheDemo.put(3,3);
        lruCacheDemo.put(3,3);
        System.out.println(lruCacheDemo.keySet());

        lruCacheDemo.put(5,5);
        System.out.println(lruCacheDemo.keySet());
    }
```



- accessOrder = true；

  内部元素根据访问顺序会重新排列，访问的元素排列到队尾。

  ```JAVA
  //output
  [1, 2, 3]
  [2, 3, 4]
  [2, 4, 3]
  [4, 3, 5]
  ```

- accessOrder = false；

  内部元素不会根据访问顺序重新排列，按照插入的顺序进行排列。

  ```java
  //output
  [1, 2, 3]
  [2, 3, 4]
  [2, 3, 4]
  [3, 4, 5]
  ```

  

### 手写LRU算法

前面分析了 LRU 算法的核心就是底层数据结构要使用哈希链表，哈希表我们可以使用 HashMap，而链表需要我们来手写一个链表（单向双向都可以，这里实现的是双向链表）。

除了实现链表本身具有的有序性外，还由于 LRU 算法要求访问过的数据放到队尾，所以必须包含以下方法。

- 添加元素到队尾。

  每次新增都插入到队尾的位置（访问、更新元素时也要放到队尾）。

- 获取头结点元素。

  在内部缓存满的时候，删除最近最久未使用元素。 

- 删除元素。

#### Node类

实现的是双向链表，包含一个前驱和一个后继。

```JAVA
/**
 * 结点类
 */
class Node<K, V> {
    K key;
    V value;
    //前驱
    Node<K, V> prev;
    //后继
    Node<K, V> next;

    public Node() {
        //初始化时，前驱和后继都是null
        this.prev = this.next = null;
    }

    public Node(K key, V value) {
        this.key = key;
        this.value = value;
        //初始化时，前驱和后继都是null
        this.prev = this.next = null;
    }

}
```

#### 双向链表

实现的双向链表，包含头尾指针，还实现了添加元素到尾部、删除结点、获取第一个节点等方法。

```java
/**
 * 双向链表
 */
class DoubleLinkedList<K, V> {
    Node<K, V> head;
    Node<K, V> tail;

    public DoubleLinkedList() {
        //头尾节点都为空
        head = new Node<>();
        tail = new Node<>();
        head.next = tail;
        tail.prev = head;
    }

    //添加到尾部
    public void addTail(Node<K, V> node) {
        node.next=tail;
        node.prev= tail.prev;
        tail.prev.next = node;
        tail.prev= node;
    }

    //删除结点
    public void remove(Node<K, V> node) {
        node.next.prev = node.prev;
        node.prev.next = node.next;
        node.prev = null;
        node.next = null;
    }

    //获取第一个结点
    public Node<K, V> getHead() {
        return head.next;
    }


}
```

#### LRU算法实现类

以 HashMap 来保存结点数据，用手写的双向链表来保存元素的访问顺序。

```JAVA
public class LruCacheDemo {

    private int cacheSize;
    //哈希表，保存元素内容
    private Map<Integer, Node<Integer, Integer>> map;
    //双向链表，保存元素顺序
    private DoubleLinkedList<Integer, Integer> doubleLinkedList;

    public LruCacheDemo(int cacheSize){
        this.cacheSize=cacheSize;
        this.map=new HashMap<>();
        doubleLinkedList=new DoubleLinkedList<>();
    }

    public int get(Integer key) {
        //不存在
        if (!map.containsKey(key)) {
            return -1;
        }
        Node<Integer, Integer> node = map.get(key);
        //调整访问节点的位置
        doubleLinkedList.remove(node);
        doubleLinkedList.addTail(node);
        return node.value;
    }

    public void put(Integer key, Integer value) {
        if(map.containsKey(key)){
            Node<Integer, Integer> oldNode = map.get(key);
            oldNode.value=value;
            //调整更新元素的位置
            doubleLinkedList.remove(oldNode);
            doubleLinkedList.addTail(oldNode);
            return;
        }
        if(map.size()>=cacheSize){
            //缓存已满，淘汰最近最久未使用的元素
            Node<Integer, Integer> tailNode = doubleLinkedList.getHead();
            map.remove(tailNode.key);
            doubleLinkedList.remove(tailNode);
        }
        //新插入元素
        Node<Integer,Integer> newNode = new Node<>(key,value);
        map.put(key,newNode);
        doubleLinkedList.addTail(newNode);
    }

    //获取排序key列表
    private List<Integer> sortKeyList(){
        List<Integer> list = Lists.newArrayList();
        //获取第一个结点
        Node<Integer, Integer> node = doubleLinkedList.head.next;
        while (node.next!=null){
            //匹配到尾指针，结束
            if(node==doubleLinkedList.tail){
                break;
            }
            list.add(node.value);
            //遍历下一个结点
            node=node.next;
        }
        return list;
    }

    public static void main(String[] args) {
        LruCacheDemo lruCacheDemo = new LruCacheDemo(3);

        lruCacheDemo.put(1,1);
        lruCacheDemo.put(2,2);
        lruCacheDemo.put(3,3);
        System.out.println(lruCacheDemo.sortKeyList());

        lruCacheDemo.put(4,4);
        System.out.println(lruCacheDemo.sortKeyList());

        lruCacheDemo.put(3,3);
        lruCacheDemo.put(3,3);
        lruCacheDemo.put(3,3);
        System.out.println(lruCacheDemo.sortKeyList());

        lruCacheDemo.put(5,5);
        System.out.println(lruCacheDemo.sortKeyList());
    }


}

//output
[1, 2, 3]
[2, 3, 4]
[2, 4, 3]
[4, 3, 5]
```



### LRU算法的缺陷







## LFU算法











LinkedHashMap 比较 HashMap 能够将元素按照插入顺序排序。内部维护了一个双向链表，每个结点都包含前驱和后继，来维护双向链表。







## 参考链接

- [https://blog.csdn.net/oneby1314/article/details/113789412](https://blog.csdn.net/oneby1314/article/details/113789412)

- [尚硅谷2021逆袭版Java面试题第三季（java大厂面试题，周阳主讲）- 手写 LRU算法](https://www.bilibili.com/video/BV1Hy4y1B78T?p=68)



