# MYSQL面试题
## 一、存储引擎

### 1.InnoDB与MyISAM的区别

事务、外键、MVCC（多版本并发控制）

- InnoDB支持事务，MyISAM不支持事务、锁、数据插入数据、主键。
- InnoDB支持外键，MyISAM不支持外键
- InnoDB 支持 MVCC(多版本并发控制)，MyISAM 不支持
- select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB就需要全表扫描。
- Innodb不支持全文索引，而MyISAM支持全文索引（5.7以后的InnoDB也支持全文索引）
- InnoDB支持表、行级锁，而MyISAM支持表级锁。
- InnoDB表必须有主键，而MyISAM可以没有主键
- Innodb表需要更多的内存和存储，而MyISAM可被压缩，存储空间较小，。
- Innodb按主键大小有序插入，MyISAM记录插入顺序是，按记录插入顺序保存。
- InnoDB 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 MyISAM 比 InnoDB 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引



## 二、索引

### 索引的类型？

- 主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。

- 唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。

- 普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。

- 全文索引：是目前搜索引擎使用的一种关键技术，对文本的内容进行分词、搜索。

- 覆盖索引：查询列要被所建的索引覆盖，不必读取数据行

- 组合索引：多列值组成一个索引，用于组合搜索，效率大于索引合并



### 索引的一些概念

1. 回表

   查询列中包含非索引列，索引需要先找到对应列的信息，再去聚簇索引里查询列的信息。

   > 比如：select name,age from user where name = '123'；只有 name 添加了索引。
   >
   > 这个时候会在 name 的索引上查询到对应结果，此时查询到的结果有 name 的信息，但是不包含 age 的信息，所以需要去聚簇索引中进行一个回表查询，获取 age 的信息。

2. 覆盖索引

   当查询列和查询条件字段都存在一个索引上时，可以直接使用单个索引查询而不需要进行回表，这就是覆盖索引。

   通过使用覆盖索引，可以减少树搜索的次数，是常用的性能优化手段。

   > 比如：select id,name from user where name = '123'；只有 name 添加了索引。
   >
   > 由于 name 列索引是非聚簇索引，所以该索引上保存了 主键id 和 name 的数据。
   >
   > 而在该索引上可以查询到 id和name字段，不需要进行回表操作。

3. 索引下推

   索引下推是数据库检索数据过程中为减少回表次数而做的优化。

   在出现复杂条件查询的情况时，若不使用索引下推，则会根据第一个条件查询出数据进行回表操作。

   使用索引下推时，就会先根据复杂条件进行过滤数据，再进行回表操作，能够有效减少回表的次数。

4. 最左前缀原则

   最左匹配原则针对复合索引，最左优先。

   若查询字段不包含复合索引左边的列，则复合索引不会生效。

### 索引失效的情况？

- 使用 like 进行模糊匹配时， % 在最左边的列。

- 使用 or 关键字时，or 左右两列有未加索引的情况。

- 查询列字段类型为字符串的时候，查询条件不加单引号的时候，有可能导致索引失效。

  > 比如：Where name = 123；
  >
  > 由于列字段类型和数字不匹配，所以无法走索引。在进行普通查询的时候，MySQL会进行隐式转换，转换为浮点数之后再比较。

- 当存在 !=，<>，not in，is null,is not null时，可能会导致索引失效。

- 复合查询时，不满足最左前缀原则。

- 在索引列上，使用MySQL的内置函数，索引失效。

- 在索引列上进行计算，索引失效。

- MySQL估计使用索引没有查询全表快，则不使用索引。

### 索引不适合的场景

- 数据量少的情况。
- 数据区分度低，重复数据多，比如性别。
- 更新比较频繁的也不适合加索引。

### 为什么使用B+树作为底层数据结构？

- 存储数据多，树的深度低，减少磁盘IO的次数。
- 叶子节点之间是链表连接，方便顺序查找和范围查找。

### 聚簇索引和非聚簇索引的区别？

- 聚簇索引每个表只有一个，按照数据表的主键Id构建B+树，叶子结点存放的是行数据。Innodb默认主键是聚簇索引，若没有定义主键，会选择非空的唯一索引代替。若没有这样的索引，会隐式的定义一个主键作为聚簇索引。
- 非聚簇索引叶子结点存储的数据是主键，查询数据需要二次查找，现在非聚簇索引上查找主键，再去聚簇索引查找行数据，又称回表。在一个表中可以有多个非聚簇索引。

### 怎样创建索引？

- 考虑最左前缀原则

- 频繁作为查询条件的字段去创建索引

- 频繁更新的字段不适合创建索引。

  > 因为更新的时候，不仅要更新数据表中的数据，还要更新索引中的数据。

- 索引列不能有函数计算，不然索引会失效。
- 在order by 或者 group by 子句中，创建索引需要注意顺序。
- 重复度高的数据列不适合创建索引。（性别）
- 有外键的列一定要加索引。
- 索引不是越多越好。

## 三.事务

### 1. 事务基本特性 

​	ACID

- 原子性
- 一致性
- 隔离性
- 持久性

### 2. 隔离级别

- 读未提交
- 读已提交
- 可重复读
- 串行读

---

![](https://cdn.jsdelivr.net/gh/AlbertYang0801/pic-bed@main/img/20210611101205.png)

- 可重复读（每次读取同一条数据时，不管数据值改变没，都是原来的值）
  会导致幻读，本来有5条数据，新增之后，读取到6条数据。
- 不可重复读取 - 第一个事务读取数据后，数据被另一个事务改变了，则第一个事务再读取就是新的数据。代表着没有办法重复读取到之前获取的数据。



### 3.常见问题

- MySQL怎么实现读已提交？

  在事务开启时，每次执行SQL都会生成一个快照。

- MySQL怎么实现的可重复读？

  在事务开启的时候，按照规则生成快照，仅仅生成一次，保证事务提交之前读取的数据快照一致。

- mysql采用可重复读怎么解决幻读的问题？

  在该隔离级别下引入间隙锁。当`Session 1`执行delete语句时，会锁住间隙。那么，`Ssession 2`执行插入语句就会阻塞住！



## 四、数据库范式

- 第一范式

  确保每一列都是不可再分的最小数据单元。

  > 比如有一列为：身高体重，就违反了第一范式。
  >
  > 如果要符合第一范式的话，就需要将该列拆分为：身高列、体重列。

- 第二范式

  首先要满足第一范式。

  表中非主键列不存在不依赖主键的情况，确保每个列都和主键相关。

  >比如表中列信息为：Id、学校和学校类别。
  >
  >此时学校类别不依赖于主键id，而依赖于学校。不符合第二范式。
  >
  >若要符合第二范式，就需要将学校和学校类别拆分出来。学校作为主键，学校类别作为普通列。

- 第三范式

  首先要满足第二范式。

  每列都和主键直接相关，而不是间接相关。

  > 比如表中存在Id、学生、爱好、学科、成绩等列。
  >
  > 此时爱好列不直接依赖于Id，而是依赖学生。不满足第三范式。
  >
  > 若要符合第三范式，要将间接相关的信息抽取出来。
  >
  > 比如将学生个人基本信息抽取出来，学生id、学生、爱好等列作为列信息。



## 参考链接

[不良人编程 — 彻底搞懂MySQL索引机制，MySQL索引优化](https://www.bilibili.com/video/BV1Bv411h7pR)

[MySQL数据库三大范式](https://juejin.cn/post/6915996132480909325)

