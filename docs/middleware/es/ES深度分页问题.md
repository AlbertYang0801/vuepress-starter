# ES深度分页问题

## from+to分页

es在查询时候默认使用的是分页查询，单次只会返回10条数据。

可以指定size。

![image.png](https://s2.loli.net/2025/06/26/ESd9BlDPsabtgTr.png)

- 查询要求默认 from+size 的结果必须不超过10000。
  
    可以通过修改配置
    
    ```java
    "index.max_result_window":"20000"
    ```
    
    限制单词查询满足条件的结果窗口的大小，由from+size共同决定。
    
    因为es是先将数据全查出来再做分页，这样做是为了限制内存的消耗。
    
    ---
    
    因为es查询场景复杂，需要先根据条件过滤出符合的数据发给协调节点。由协调节点进行分页操作。
    
    整个过程将查出来的数据放到了内存中，再去操作。
    
    <aside>
    💡
    
    改配置只能解决一时的问题，当索引的数据量持续增长时，在查询全量数据时很容易把内存吃完。
    
    </aside>
    

## Scroll深度分页

[es滚动查询-Scroll](https://flowus.cn/cfa70242-873e-445f-b27a-19c273393fd4)

*使用游标查询可以分批查，不用把数据全量加载到内存中。*

- 初始化滚动查询
  
    首次发出滚动查询请求后，es会执行查询并返回第一批结果，和游标ID - ScrollId。
    
- 存储上下文
  
    根据滚动查询，创建上下文保存到内存中，标志查询的环境和数据快照的版本，记录es接下来要从哪里查数据。
    
- 分批获取结果
  
    根据ScrollId获取上下文，然后按照顺序接着往下读，直到所有符合条件数据全都返回。
    

> 虽然上下文在内存中保存，但并不是将所有数据加载到内存中。每次滚动请求仅返回请求的数量，而剩余的数据仍然存储在磁盘上。这样可以避免因大量数据而导致的内存溢出问题，同时也保证了高效率和低延迟的查询响应。